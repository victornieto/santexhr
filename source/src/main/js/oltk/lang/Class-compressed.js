;(function(){oltk.namespace('oltk.lang');oltk.lang.Class=function(){};oltk.lang.Class.extend=function(props){var Class=_subClass(this);for(var name in props){if(name==='$implements'){throw'Class.extend: "$implements" property is reserved';}
else if(name==='$mixin'){throw'Class.extend: "$mixin" property is reserved';}
else if(name==='$static'){throw'Class.extend: "$static" property is reserved';}
else{_applyPrototype(Class,new Property(name,props));}}
if(this.prototype.$inherited){this.prototype.$inherited(Class);}
return Class;};var initializing=false;var fnTest=/xyz/.test(function(){xyz;})?/\b_super\b/:/.*/;function _subClass(superclass){var Class=function(){if(!initializing&&this.$constructor){this.$constructor.apply(this,arguments);}};initializing=true;Class.prototype=new superclass();initializing=false;Class.constructor=Class;Class.extend=superclass.extend;return Class;};function _applyPrototype(Class,property){if(property.overrides(Class.prototype)){property.override(Class.prototype);}
else{property.append(Class.prototype);}};function Property(s,o){this.name=s;this.isConstructor=this.name==='$constructor';this.reference=o[s];this.isMethod=typeof this.reference==='function';};Property.prototype={overrides:function(superclass){return this.isMethod&&typeof superclass[this.name]==='function'&&fnTest.test(this.reference);},override:function(o){o[this.name]=(function(fn,superclassFn){return function(){var tmp=this._super;this._super=superclassFn;var result=fn.apply(this,arguments);return result;}})(this.reference,o[this.name]);},append:function(o,bind){o[this.name]=bind&&this.isMethod?oltk.bind(this.reference,o):this.reference;}};})();